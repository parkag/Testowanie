Przyk³ad 9.5. Zapytania o najbli¿szego s¹siada zrealizowane na kd-drzewie
// Metoda z klasy KDTree
public IMultiPoint nearest (IMultiPoint target) {
   if (root == null) return null;

   // ZnajdŸ wêze³ rodzicielski, do którego mo¿na by wstawiæ element
   // docelowy. To jest nasz najlepszy strza³, jeœli chodzi o zlokalizowanie
   // najbli¿szego punktu; oblicz najlepsz¹ odleg³oœæ trafion¹ do tej pory
   DimensionalNode parent = parent(target);
   IMultiPoint result = parent.point;
   double smallest = target.distance(result);

   // Teraz zacznij znów od korzenia i sprawdzaj wszystkie prostok¹ty,
   // które mog¹ zachodziæ na tê najmniejsz¹ odleg³oœæ. Jeœli znaleziono
   // lepszy, to zwróæ go
   double best[] = new double[] { smallest };

   double raw[] = target.raw();
   IMultiPoint betterOne = rot.nearest (raw, best);
   if (betterOne != null) { return betterOne; }
   return result;
}

// Metoda z klasy DimensionalNode. Tablica min[0] zawiera najlepsz¹
// (najkrótsz¹) obliczon¹ odleg³oœæ
IMultiPoint nearest (double[] rawTarget, double min[]) {
   // Uaktualnij minimum, jeœli jesteœmy bli¿ej
   IMultiPoint result = null;

   // Jeœli krótsza, uaktualnij minimum
   double d = shorter(rawTarget, min[0]);
   if (d >= 0 && d < min[0]) {
      min[0] = d;
      result = point;
   }

   // Ustal, czy musimy zag³êbiaæ siê w poddrzewa, obliczaj¹c
   // bezpoœredni¹ odleg³oœæ prostopad³¹ do osi, wzd³u¿ której wêze³
   // dzieli p³aszczyznê. Jeœli d jest mniejsza ni¿ aktualnie najkrótsza
   // odleg³oœæ, to moglibyœmy "zabrn¹æ" w p³aszczyznê, trzeba wiêc
   // sprawdziæ jedno i drugie
   double dp = Math.abs(coord – rawTarget[dimension-1]);
   IMultiPoint newResult = null;

   if (dp < min[0]) {
      // Trzeba siê zag³êbiæ w oba. Zwróæ najbli¿sze
      if (above != null) {
         newResult = above.nearest(rawTarget, min);
         if (newResult ! = null) { result = newResult; }
      }

      if (below != null) {
         newResult = below.nearest(rawTarget, min);
         if (newResult ! = null) { result = newResult; }
      }
   } else {
      // Trzeba wejœæ tylko w jedno! Ustal, w które
      if (rawTarget[dimension-1] < coord) {
         if (below != null) {
            newResult = below.nearest(rawTarget, min);
         }
      } else {
         if (above != null) {
            newResult = below.nearest(rawTarget, min);
         }
      }

      // U¿yj mniejszego wyniku, jeœli go znaleziono
      if (newResult != null) { return newResult; }
   }
   return result;
}
